# CODE BEEP

사용자가 알람 받길 원하는 시간을 지정하고, 지정된 시간에 알람이 울립니다. 사용자가 작성했던 코드들로 다양한 문제를 제공하여 잠을 깨워 줍니다.

## 목차

- [기획 동기](#기획-동기)
- [개발 환경](#개발-환경)
- [UI 미리보기](#ui-미리보기)
- [구현 기능 1. Github API를 활용해 사용자의 코드 가져오기](#구현-기능-1-github-api를-활용해-사용자의-코드-가져오기)
  - [방법 1. 가장 최근 업데이트된 리포지토리를 기준으로 코드 가져오기](#방법-1-가장-최근-업데이트된-리포지토리를-기준으로-코드-가져오기)
    - [문제점 1: Rate Limit 발생 가능성 높음](#문제점-1-rate-limit-발생-가능성-높음)
    - [문제점 2: 사용자가 작성한 코드를 구분하기 어려움](#문제점-2-사용자가-작성한-코드를-구분하기-어려움)
  - [방법 2. 리포지토리의 최근 커밋에서 코드 가져오기](#방법-2-리포지토리의-최근-커밋에서-코드-가져오기)
    - [한계점: 커밋에 코드 변경이 포함되지 않을 수 있음](#한계점-커밋에-코드-변경이-포함되지-않을-수-있음)
    - [해결 방법: 커밋과 로직 모두 활용하기](#해결-방법-커밋과-로직-모두-활용하기)
- [구현 기능 2. 사용자의 코드 파싱하기](#구현-기능-2-사용자의-코드-파싱하기)
  - [방법 1. Tree-sitter를 활용해 파서 생성하기](#방법-1-tree-sitter를-활용해-파서-생성하기)
    - [문제점 1. Tree-sitter 사용 중 실행 환경 문제로 인한 에러 발생](#문제점-1-tree-sitter-사용-중-실행-환경-문제로-인한-에러-발생)
    - [문제점 2. Node 버전으로 인한 Node.js 라이브러리 사용 어려움](#문제점-2-node-버전으로-인한-nodejs-라이브러리-사용-어려움)
  - [방법 2. peggy를 활용해 분석하기](#방법-2-peggy를-활용해-분석하기)
- [구현 기능 3. 기상 미션 퀴즈 생성하기](#구현-기능-3-기상-미션-퀴즈-생성하기)
  - [구현 방식: AST 데이터를 탐색해 랜덤한 하나의 값 추출해 코드 빈칸 생성하기](#구현-방식-ast-데이터를-탐색해-랜덤한-하나의-값-추출해-코드-빈칸-생성하기)
  - [개선해야 할 부분: 다양한 프로그래밍 언어 지원하기](#개선해야-할-부분-다양한-프로그래밍-언어-지원하기)
    - [한계: 커스텀으로 생성된 파서의 부정확성](#한계-커스텀으로-생성된-파서의-부정확성)
    - [해결 방안: web-tree-sitter 도입 방안 검토하기](#해결-방안-web-tree-sitter-도입-방안-검토하기)
- [구현 기능 4. 등록된 알람 시간 확인하기](#구현-기능-4-등록된-알람-시간-확인하기)
  - [1. Foreground Service를 활용해 Background 작업 지정하기](#1-foreground-service를-활용해-background-작업-지정하기)
  - [2. 현재 시각과 알람 등록된 시간을 비교해 알람 실행하기](#2-현재-시각과-알람-등록된-시간을-비교해-알람-실행하기)
  - [문제 발생: ANR Error 발생 원인과 코드 개선하기](#문제-발생-anr-error-발생-원인과-코드-개선하기)
    - [해결 방법: Alarm Manager를 이용해 기기에 알람 예약하기(진행 중)](#해결-방법-alarm-manager를-이용해-기기에-알람-예약하기진행-중)
- [구현 기능 5. 앱 실행 시 자동 로그인 진행](#구현-기능-5-앱-실행-시-자동-로그인-진행)
  - [1. 사용자 정보를 어디에 저장할까?](#1-사용자-정보를-어디에-저장할까)
  - [2. 자동 로그인 기능 구현하기](#2-자동-로그인-기능-구현하기)
- [개인 회고](#개인-회고)

## 기획 동기

개발자들은 매일 코드를 작성하거나 수정하지만, 이전 작업을 돌아볼 기회는 많지 않습니다. 아침에 알람을 끌 때 전날 작성한 코드를 떠올리며 하루를 시작하면 작업의 흐름을 이어가는 데 도움이 될 것이라는 생각에서 이 프로젝트가 시작되었습니다.
사용자의 깃허브에서 최신 작업을 가져와 빈칸 퀴즈 형태로 제공해, 알람 해제 과정에서 자연스럽게 코드를 복습할 수 있도록 기획했습니다.

## 개발 환경

![javascript](https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black) ![React](https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black) ![React Native](https://img.shields.io/badge/react_native-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB) ![Expo](https://img.shields.io/badge/expo-1C1E24?style=for-the-badge&logo=expo&logoColor=#D04A37) ![Firebase](https://img.shields.io/badge/firebase-a08021?style=for-the-badge&logo=firebase&logoColor=ffcd34) ![Zustand](https://img.shields.io/badge/zustand-592E42?style=for-the-badge&logo=zustand&logoColor=#592E42)
![javascript](https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black) ![React](https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black) ![React Native](https://img.shields.io/badge/react_native-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB) ![Expo](https://img.shields.io/badge/expo-1C1E24?style=for-the-badge&logo=expo&logoColor=#D04A37) ![Firebase](https://img.shields.io/badge/firebase-a08021?style=for-the-badge&logo=firebase&logoColor=ffcd34) ![Zustand](https://img.shields.io/badge/zustand-592E42?style=for-the-badge&logo=zustand&logoColor=#592E42)

## UI 미리보기

![code beep ui preview](https://github.com/user-attachments/assets/44ecdc0d-cae2-4169-bf66-28dc8f8e519c)

## 구현 기능 1. Github API를 활용해 사용자의 코드 가져오기

**사용자의 코드를 어떤 기준으로 가져오는 게 좋을까?**

사용자의 코드를 활용해 퀴즈를 생성하기로 기획했을 때, 어떤 기준을 잡으면 좋을까에 대해 고민했습니다. 모든 리포지토리의 코드를 가져오기에는 Github의 Rate Limit을 피하기는 현실적으로 불가능하며, 사용자가 수정한 지 좀 지난 리포지토리라면 어떤 코드를 작성했었는지 기억하기 어려울 것이라 판단했기 때문입니다.

이에 어떤 기준으로 코드를 가져오면 좋을지 고민했습니다. 그러다 사용자가 가장 최근 업데이트 한 리포지토리의 코드를 가져온다면 현재 진행 중인 작업의 흐름을 이어갈 수 있겠다는 생각이 들었습니다.

그래서 처음 시도한 방식은 최근 업데이트 된 리포지토리의 정보를 이용하는 것이었습니다.

### 방법 1. 가장 최근 업데이트된 리포지토리를 기준으로 코드 가져오기

리포지토리를 활용해 코드를 가져오는 순서는 아래와 같습니다.

1.  리포지토리를 업데이트 순으로 1개만 요청
2.  리포지토리 내부 파일 요청
    - 디렉토리일 경우 디렉토리 내부 파일에도 요청
3.  받아온 파일 내부 코드 요청

이렇게 하면 가장 최근 업데이트 된 리포지토리를 통해 파일을 가져올 수 있습니다.

**1-1. Rate limit 제한 피하며 요청 보내기**

리포지토리의 경우 모든 파일을 탐색하는데, 디렉토리에 요청 하나, 디렉토리 내부의 파일 당 요청 하나씩 보내게 됩니다.

<img width="600" alt="Image" src="https://github.com/user-attachments/assets/ab308970-e79d-43ed-ac96-0d0687308fc8" />

<br />

리포지토리 내부를 탐색하는 과정에서 불필요한 API 요청으로 인한 Rate Limit 오류를 막기 위해 4단계 이상의 디렉토리가 감지되면 API 요청을 중단하고 다음 파일로 넘어가도록 설정했습니다.

<br />

**1-2. 사용자가 작성한 파일 필터링 하기**

최대한 사용자가 작성한 코드를 활용해 퀴즈를 생성하기 위해 파일에서 코드를 요청할 때 필터링을 거치도록 설계했습니다. 필터링 단계는 아래와 같습니다.

<img width="600" alt="Image" src="https://github.com/user-attachments/assets/b57fc2bd-d6f5-44c9-b78f-71b10b0fae85" />

<br />

1. 파일 확장자가 `.js` 등의 프로그래밍 언어일 경우 코드를 요청한다.
2. 요청된 코드에 `function`, `if`, `for` 등 예약어가 존재할 경우 저장한다.
3. 요청한 파일이 위 조건에 해당하지 않을 경우, 다른 파일의 코드를 요청한다.

하지만 이러한 대처에도 문제가 발생했습니다.

#### 문제점 1: Rate Limit 발생 가능성 높음

GitHub REST API의 Rate Limit은 시간 당 5,000개로 제한합니다. 리포지토리 내부를 탐색하며 파일을 가져오거나 파일 내부 코드를 요청할 때에도 파일 당 한 번의 요청을 보내게 됩니다.

현재는 디렉토리가 4단계 이상으로 들어가게 된다면 요청을 보내지 못 하도록 제한하고 있습니다.

하지만 리포지토리를 요청하게 되는 경우 내부에 탐색해야 하는 파일이 많다면 Github API 규정에 의해 Rate Limit이 발생할 수 있습니다.
즉, 디렉토리 탐색을 4단계로 제한한다고 해도 리포지토리 자체의 크기가 크다면 요청이 많아질 수밖에 없습니다.

#### 문제점 2: 사용자가 작성한 코드를 구분하기 어려움

리포지토리 전체를 탐색하는 경우 명확하게 사용자가 작성한 로직이 있는 파일인지는 알기 어렵습니다. 리포지토리에서 파일을 요청할 때 `.js`로 끝나는 경우에만 요청하지만, 완벽하게 필터링 되지 않으며 다시 파일 내부의 코드를 요청해야지만 함수와 같은 로직이 있는지 확인할 수 있습니다.

이렇게 되면 리포지토리에서 파일을 요청하고, 파일에서 다시 코드를 요청하는 단계를 거쳐야지만 사용할 수 있는 코드인지 알 수 있게 됩니다.

이러한 문제로 다른 방식을 생각해야 했습니다.

### 방법 2. 리포지토리의 최근 커밋에서 코드 가져오기

다음으로 시도한 방식은 커밋 정보를 활용하는 것입니다. 최근 커밋에서 수정된 파일을 기준으로 코드를 가져오는 방법을 생각했습니다. 가져오는 순서는 아래와 같습니다.

1. 가장 최근 업데이트 된 리포지토리 1개 요청
2. 리포지토리에서 가장 최근 커밋 요청
3. 커밋에서 수정된 파일 정보를 가져와 내부 코드 요청

#### 왜 커밋을 이용했을까?

리포지토리 전체를 탐색하는 방식은 많은 API 요청을 유발하고, 사용자가 작성한 로직을 추출하는 데도 부정확성이 존재합니다. 반면, 커밋은 개발자가 실제로 최근에 작업한 코드 변경 내역만을 포함하므로, 아래와 같은 이유로 더 효과적인 방식이 될 수 있습니다.

| 구분                          | ❌ 리포지토리 모든 파일                                                                                                  | ✅ 리포지토리 최신 커밋                                                                                            |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------ |
| **Rate Limit 발생 가능성**    | 렉토리 구조를 재귀적으로 순회해야 하며, 파일 수가 많을 경우 요청량 증가 <br /> → Rate Limit 위험 높음                    | 커밋 내 수정 파일만 조회하므로, 깊은 디렉토리 탐색 불필요 <br /> → API 요청 수 최소화, 효율적 탐색 가능            |
| **사용자가 작성한 코드 여부** | 전체 파일을 탐색하므로, 오래된 코드나 외부 라이브러리까지 포함될 수 있음 <br /> → 사용자가 작성한 코드만 추출하기 어려움 | 커밋은 사용자의 작업 이력을 반영하므로, 직접 수정한 코드에 집중 가능 <br /> → 자동 생성/외부 파일 제외 가능성 높음 |

리포지토리를 전체 탐색하는 경우, `.js`와 같은 확장자인 파일의 코드를 요청하게 됩니다. 원하는 결과가 나올 때까지 요청하기 때문에, 사용량이 어떻게 될지 예상하기 어렵습니다. 또한 리포지토리 내 모든 파일을 가져오기 때문에 설정 파일 등을 구분하기 어렵다는 한계점이 있었습니다.

하지만 커밋 내역을 활용할 경우, 커밋에서 변경된 파일에 한해서 `.js` 확장자를 찾고 파일에서 코드를 요청합니다. 또한 초기 프로젝트 설정을 제외하고는 사용자가 작성한 코드가 포함될 가능성이 높다고 판단했습니다.

이러한 이유로 커밋을 이용했습니다.

#### 한계점: 커밋에 코드 변경이 포함되지 않을 수 있음

모든 커밋이 코드 수정을 포함하는 것은 아닙니다. 예를 들어, 문서 파일을 수정하거나(`README.md` 등), 파일 이름을 변경하거나, 불필요한 파일을 삭제하는 등의 작업만 포함된 커밋도 존재합니다. 이런 경우에는 실제 코드 로직이 없기 때문에 원하는 데이터를 얻기 어렵고, 이에 대응할 수 있는 보완책이 필요했습니다.

#### 해결 방법: 커밋과 로직 모두 활용하기

모든 커밋이 코드 수정을 포함하는 것은 아니기 때문에, 코드만을 기준으로 삼는 데에는 한계가 있습니다. 반면 커밋 메시지는 항상 존재하며, 최근 작업의 흐름을 반영합니다. 따라서 커밋 메시지를 함께 활용하면 코드가 없는 경우에도 최근 작업 내용을 기준으로 일관된 처리가 가능해집니다. 이를 통해 코드 유무에 관계없이 안정적으로 데이터를 활용할 수 있습니다.

## 구현 기능 2. 사용자의 코드 파싱하기

사용자의 코드를 정확하게 분석하기 위해서는 파서를 사용해야 한다고 판단했습니다. 이 때문에 파서 생성기를 사용해 파서를 만들고, 만들어진 파서를 이용해 코드를 파싱하기로 결정했습니다.

### 방법 1. Tree-sitter를 활용해 파서 생성하기

이를 위해 여러 파서 라이브러리를 비교했습니다. 우선적으로 코드를 분석하는 것에는 정확성이 가장 중요하다 생각했기 때문에, 여러 프로그래밍 언어의 문법을 제공해 주는 라이브러리를 사용해야겠다고 판단했습니다. 그에 따라 가장 많이 사용되는 `ANTLR4`, `Tree-Sitter` 두 가지 라이브러리를 비교했습니다.

|             | 제공하는 언어                                                               | 장점                                                                                                                    | 단점                                                                                                                                                                 |
| ----------- | --------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ANTLR4      | C++14, JavaScript, Python, Java 등<br>(공식 및 커뮤니티에서 일부 문법 제공) | - Lexer와 파서를 구분해 정의 가능<br>- 복잡한 문법을 처리할 때도 안정적인 성능                                          | - 문법 정의가 직관적이지 않음<br>- 파싱 과정에서 복잡한 데이터 구조를 사용하여 메모리 사용량이 많을 수 있음<br>- 복잡한 문법 처리 기능으로 인해 라이브러리 무게 증가 |
| Tree-sitter | JavaScript, Python, C, Java, TypeScript 등 여러 프로그래밍 언어 제공        | - JSON 형태의 AST 출력<br>- 많은 언어에 대한 기존 문법 제공<br>- 순수 C로 작성된 경량 라이브러리로 리소스 사용량이 적음 | - 다른 언어로의 직접적인 코드 생성은 제한적<br>- AST 기반의 분석만 가능                                                                                              |

이 두 가지의 라이브러리 중 AST 기반의 분석을 하고 리소스 사용량이 적은 `Tree-sitter`가 더 제 프로젝트에 적합하다 생각했습니다. 그래서 `Tree-sitter`를 통해 사용자의 코드를 파싱하려고 시도했습니다.

#### 문제점 1. Tree-sitter 사용 중 실행 환경 문제로 인한 에러 발생

`Tree-sitter`를 사용할 때는 프로그래밍 언어의 문법을 정의되어 있는 또 다른 라이브러리를 설치하게 됩니다. 그러나 프로젝트를 Build 과정에서 아래와 같은 에러가 발생했습니다.

![tree-sitter 실행 환경 에러](https://github.com/user-attachments/assets/36af8456-a538-47a2-9978-5cc639c58a29)

에러 발생 원인은 `tree-sitter-javascript` 라이브러리가 Node 표준 라이브러리인 `path`를 가져오려고 시도한다는 것이었습니다. Node.js는 다양한 빌트인 모듈(built-in modules, 설치 시 기본적으로 제공되는 모듈)을 제공하는 표준 라이브러리(Standard Library)를 포함하고 있습니다.

이 프로젝트는 안드로이드 애플리케이션이기 때문에 Node를 사용하지 않아 `tree-sitter-javascript`가 필요로 하는 Node 표준 라이브러리를 제공하지 못 해서 발생한 문제였습니다. 그리하여 Nodejs를 모바일에서 사용할 수 있는 방향을 고민했습니다.

#### 문제점 2. Node 버전으로 인한 Node.js 라이브러리 사용 어려움

React Native 라이브러리 중 `Node.js` 환경을 제공하는 라이브러리가 있다는 것을 알게 되었습니다. `Nodejs-mobile-react-native`를 설치하게 되면 프로젝트 내부에 또다른 `Node.js` 환경의 프로젝트가 생성되며, 이곳에 필요한 라이브러리도 설치할 수 있게 됩니다. 다만 이 라이브러리의 경우 Node의 버전이 18을 필요로 한다는 점 때문에 Node 버전을 18로 다운그레이드 후 진행했습니다.

<img src="https://github.com/user-attachments/assets/38d9975d-3522-4039-85ef-4fc3e88f89c7" width="500" />

그러나 빌드를 시도할 때 위와 같은 에러가 발생하게 됩니다. 이 에러는 허용되지 않는 아키텍처가 포함되어 있다는 내용으로, `nodsjs-mobile-react-native`의 경우 `x86` 아키텍처를 지원하지 않지만, 빌드 대상에는 `x86` 아키텍처가 존재한다는 것입니다.

이 문제를 해결하기 위해서는 `nodejs-mobile-react-native`의 이전 버전으로 다운그레이드 하면 된다는 해결법을 발견했지만, 그렇게 되면 `Node`의 버전을 다시 다운그레이드해야 했습니다. React Native에서는 최소 `18.18` 이상의 Node 버전을 요구하기 때문에 이 방식은 맞지 않다고 판단했습니다.

이러한 이유로 `Tree-sitter`가 아닌 다른 파서 라이브러리를 사용해야겠다는 결론을 내리게 되었습니다.

### 방법 2. peggy를 활용해 분석하기

React Native에서 실행되는 파서 라이브러리 중 peggy를 선택하게 된 이유는 아래와 같습니다.

1. PEG 기반의 문법을 사용하여 사람이 읽고 이해하기 쉬운 문법을 작성할 수 있다.
2. 가볍고 빠른 Pasing이 가능하다.
3. 어떤 환경에 의존하여 동작하지 않기 때문에 React Native에서도 실행이 가능하다.

peggy 라이브러리의 경우 PEG 문법을 기반으로 합니다. PEG 문법이란 형식 언어를 나타내는 문법의 일종으로, 프로그래밍 언어 및 기타 구조적 데이터를 구문 분석하는 데 사용됩니다.

사용자의 코드에서 함수 이름, 매개 변수, 반환값 등의 값을 활용해 퀴즈를 만들게 됩니다. 매개 변수의 경우에는 코드 내부에서 사용된 모든 곳을 함께 빈칸으로 처리하려고 했습니다. 코드 내부에서 매개 변수인지 일반 변수인지 등을 정확하게 구분하기에는 AST(Abstract Syntax Tree) 데이터로 추출하는 것이 맞다고 판단했습니다.

> **AST(Abstract Syntax Tree)란?** <br />
> 추상 구문 트리(abstract syntax tree, AST), 또는 구문 트리(syntax tree)는 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이다. 이 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다.

<details>
<summary>peggy를 활용해 함수 이름, 매개 변수, 반환값을 AST 데이터로 추출하기(코드)</summary>

```peg
{
  function extractParams(params) {
    return params.map(param => param.name);
  }
}

Program
  = statements:Statement* { return statements; }

Statement
  = FunctionDeclaration
  / Other

FunctionDeclaration
  = "function" _ name:Identifier _ "(" params:ParameterList? ")" _ "{" body:Statement* "}"
    {
      return {
        type: "FunctionDeclaration",
        name,
        params: params ? extractParams(params) : [],
        body
      };
    }

ParameterList
  = first:Identifier rest:(_ "," _ Identifier)* {
      return [first, ...rest.map(r => r[3])];
    }

Identifier
  = name:[a-zA-Z_$][a-zA-Z0-9_$]* {
      return { type: "Identifier", name: name };
    }

Other
  = [^]  { return { type: "Other", value: text() }; }

_ "whitespace"
  = [ \t\n\r]*
```

</details>

## 구현 기능 3. 기상 미션 퀴즈 생성하기

퀴즈를 생성하는 단계는 아래와 같습니다.

> 1. AST 데이터를 탐색해 랜덤하게 하나의 값 추출하기
>    - 이때 추출된 값은 퀴즈의 정답이 됩니다.
> 2. 사용자의 코드에서 해당하는 값(퀴즈의 정답)이 있는 곳은 모두 빈칸 처리하기
>    - 빈칸 처리된 코드는 추후 알람이 울렸을 때 UI에 제공됩니다.

### 구현 방식: AST 데이터를 탐색해 랜덤한 하나의 값 추출해 코드 빈칸 생성하기

퀴즈의 정답은 모든 후보(함수 이름, 매개 변수, 반환 값)을 리스트에 넣고 랜덤하게 추출했습니다. 이때 퀴즈를 생성하는 로직은 아래의 단계를 가집니다.

**단계 1: 코드 영역 추출**

전체 파일에서 함수 부분만 추출해 파싱하기 위해 각 줄을 확인하며 `function` 혹은 `=>`와 같은 함수 정의의 키워드를 찾습니다. 이 위치를 기준으로 파일의 나머지 부분을 잘라내어 함수 코드 영역만 남기게 됩니다.

이 단계는 전체 코드 중에서 실제로 처리할 대상인 함수 정의만을 선택해 후속 작업의 정확도를 높이게 됩니다.

**단계 2: 코드 파싱 및 AST 생성**

추출한 함수 코드를 peggyjs 기반으 안에서 파서를 사용해 AST(추상 구문 트리)로 변환합니다. AST는 코드`web-tree-sitter`를 사용한다면 제대로 동작할 가능성이 있습니다. 퀴즈 부분을 트리 형태로 표현해, 사용자에게 보여지는 퀴즈 부분을 Web 상에서 제작하고, 이를 React Native의 Web노드에 접근할 수 있도록 합니다.

<img src="https://github.com/user-attachments/assets/b6641ac3-6fc9-44a3-bb29-d8d0bbc9f0eb" width="400" />

만약 파싱 과정에서 오류가 발생하면, 이후 처리 없이 기본 메타 정보만 반환하도록 설계되었습니다. 만약 파싱 과정에서 AST를 뱉지 않는다면, 커밋 메시지를 활용해 퀴즈를 생성하게 됩니다.

**단계 3: DFS 기반 AST 순회 및 후보 수집**

생성된 AST를 대상으로 깊이 우선 탐색(DFS) 알고리즘을 사용해 모든 노드를 순회합니다. 이때 stack 구조를 활용해 트리의 각 노드와 그 부모 정보를 저장합니다.

순회 중에 특정 조건(예: 식별자, 매개변수 목록 등)에 해당하는 노드를 만나면, 그 노드의 값과 코드 상 위치(시작 및 종료 인덱스)를 후보 목록에 저장합니다.

> **DFS(Depth First Search) 알고리즘이란?** <br />
>
> 깊이 우선 탐색 알고리즘으로, 트리나 그래프에서 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방식이다. 대표적으로 백트래킹(모든 경우의 수를 전부 고려하는 알고리즘)을 사용하는 알고리즘이다.

**단계 4: 랜덤 선택 및 정답 마스킹**

후보 목록에서 하나의 값을 무작위로 선택해 정답으로 결정합니다. 선택된 후보의 코드 상 위치 정보를 이용해 해당 부분을 ‘■’ 문자로 대체합니다. 이후 전체 함수 코드를 줄 단위로 분리한 뒤, 정답이 포함된 줄을 제외하고는 //... 표시로 생략 처리합니다.

이는 모바일 기기처럼 화면 크기가 제한된 환경에서 모든 코드를 한 번에 표시하면 불편할 수 있기 때문입니다. 대신, 커밋 링크와 리포지토리 및 파일 이름을 제공하여 사용자가 필요 시 전체 코드를 확인할 수 있도록 해결책을 마련했습니다.

<img src="https://github.com/user-attachments/assets/6aa5c8d6-cf29-4a28-a311-6a8b5db0588e" width="400" />

**단계 5: 최종 결과 반환**

마지막으로, 이전 단계에서 처리한 코드(퀴즈)와 함께 관련 메타 정보를 하나의 결과 객체로 통합해 반환하도록 했습니다.

만약 파싱이나 AST 생성 단계에서 문제가 발생했다면, 코드 관련 정보 없이 메타 정보만 반환하도록 되어 있습니다. 이렇게 하면 전체 과정의 실패 여부에 따라 유연하게 대응할 수 있습니다.

### 개선해야 할 부분: 다양한 프로그래밍 언어 지원하기

현재 프로젝트는 자바스크립트만 지원하지만, 여러 언어를 지원할 수 있다면 프로젝트의 활용도가 더욱 높아질 것입니다.

#### 한계: 커스텀으로 생성된 파서의 부정확성

현재 사용 중인 커스텀 파서는 자바스크립트 코드도 완벽하게 파싱하지 못할 정도로 예외 처리가 미흡합니다. 이 상태에서 다른 언어로 확장하는 것은 더욱 복잡해지며, 기대하는 수준의 정확도를 보장하기 어렵습니다.

#### 해결 방안: web-tree-sitter 도입 방안 검토하기

대안으로, 다양한 프로그래밍 언어를 파싱할 수 있는 web-tree-sitter 라이브러리를 도입하는 방안을 모색할 수 있습니다. web-tree-sitter는 웹어셈블리 파일을 사용하여 각 언어의 문법에 기반한 구문 분석을 수행합니다. 이를 위해 각 프로그래밍 언어의 문법을 담은 WebAssembly(`.wasm`) 파일이 필요합니다.

사용자에게 보여지는 퀴즈 콘텐츠는 웹 환경에서 제작하고, React Native의 `WebView`로 띄우는 방식을 고려하고 있습니다. 이렇게 하면 web-tree-sitter를 통한 파싱 결과를 효과적으로 앱에 반영할 수 있습니다.

> **WebView란?**
>
> 모바일 애플리케이션 내에서 웹 페이지나 웹 기반 콘텐츠를 표시할 수 있는 컴포넌트이다. 이를 통해 앱 내에서 브라우저 기능을 활용할 수 있다.

**web-tree-sitter로 시도했던 방식**

초기에는 `WebView`에 직접 HTML 마크업을 전달하고, CDN으로 배포된 ES 모듈 형식의 라이브러리(web-tree-sitter)를 브라우저에서 불러와 사용하는 방식을 시도했습니다. 하지만 WebAssembly(`.wasm`) 파일의 로드 및 초기화 문제로 인해, 이 방식에서는 파서가 정상적으로 동작하지 않았습니다.

따라서 최종적으로는 코드 파싱 전용 웹 페이지를 별도로 호스팅하고, React Native의 `WebView`와 메시지를 통해 통신하는 방식으로 구조를 변경하는 방안을 검토하고 있습니다.

> **CDN이란?**
>
> 라이브러리나 정적 자원을 전 세계에 분산된 서버를 통해 빠르게 제공하는 네트워크를 말한다.
>
> **WebAssembly란?**
>
> 웹 브라우저에서 고성능으로 코드를 실행할 수 있도록 설계된 바이너리 형식의 저수준 언어로, 자바스크립트보다 빠른 실행 속도를 제공하며, 다양한 프로그래밍 언어로 작성된 코드를 웹에서 실행할 수 있다.

**발생 가능한 문제 및 고려 사항**

`WebView`는 활성화될 때 내부 스크립트가 실행되므로, `WebView`가 켜지기 전까지 파서가 동작하지 않습니다. 이 경우, 알람이 실행되는 시점에 즉시 코드를 파싱하고 퀴즈를 생성해야 하는 요구사항과 충돌할 수 있으므로, 알람 실행 시 별도의 백그라운드 프로세스로 미리 파싱 작업을 완료한 후 결과를 `WebView`에 전달하는 추가적인 해결책을 고려해야 합니다.

## 구현 기능 4. 등록된 알람 시간 확인하기

용자가 등록한 시간에 알람을 제공하기 위해서는 애플리케이션 실행 여부와 상관없이 지속적으로 시간을 확인하고 있어야 한다고 생각했습니다.

그래서 Android에서 제공하는 Foreground Service API를 활용하여 백그라운드 작업을 지정했습니다. Foreground Service란 사용자에게 직접적으로 보이지 않더라도 백그라운드에서 수행되어야 하는 작업을 위해 사용됩니다. React Native에서 이것을 지원하는 라이브러리인 `react-native-background-actions`를 사용했습니다.

### 1. Foreground Service를 활용해 Background 작업 지정하기

`react-native-background-actions`의 특징은 제한없이 백그라운드 작업을 실행할 수 있다는 것입니다. 시간을 확인하기 위한 작업에 적합하다 생각했습니다. Foreground Service를 사용하려면 애플리케이션이 권한을 요청해야 합니다. 권한 요청은 아래와 같은 네이티브 코드를 작성하게 됩니다.

```kt
<uses-permission android:name="android.permission.FOREGROUND_SERVIСЕ" />
```

이렇게 라이브러리를 설치하게 되면 Native 코드와 함께 포함한 채로 설치가 됩니다. 아래와 같이 `node_modules` 내부 라이브러리 폴더에는 Android 폴더가 생성됩니다. 여기에 라이브러리에 필요한 Native 코드가 담겨 설치된 것입니다.

```zsh
📂 node_modules/react-native-background-action
├── CHANGELOG.md
├── LICENSE
├── README.md
├── android // 이 곳에 Native 코드를 함께 설치하게 됩니다.
...
```

이렇게 설치된 Native 코드는 React Native의 Auto Link라는 기능으로 Native와 연결하게 됩니다. React Native 0.60 버전부터 자동 연결(Auto-linking) 기능이 추가되어, 네이티브 코드를 자동으로 프로젝트에 추가해 줍니다.

### 2. 현재 시각과 알람 등록된 시간을 비교해 알람 실행하기

알람 시간을 확인하는 순서는 아래와 같습니다.

1. 현재 요일과 알람 데이터의 요일이 같은지 확인한다.
2. 요일이 같다면 현재 시간을 지속적으로 상태에 저장한다.
3. 현재 시간이 저장된 상태와 등록된 알람 데이터 중 일치하는 데이터가 있는지 확인한다.
4. 현재 시간과 등록된 데이터의 시간이 일치한다면 상태를 변경한다.

불필요한 시간 확인을 막기 위해 현재 요일과 일치하는 요일을 가진 알람 데이터가 있는지 찾는 작업을 가장 먼저 진행합니다. 만약 해당 시간을 먼저 확인한다면 불필요한 상황에서도 Background 스레드의 업데이트를 유발하기 때문입니다.

요일이 일치한다면 Background 스레드에서 반복적으로 현재 시간을 업데이트합니다. 업데이트된 시간과 등록된 알람 데이터의 시간을 확인하며 일치하는 데이터가 있는지 확인합니다.

이러한 과정을 거치며 데이터가 일치했을 때 Background 스레드에서 전역 상태를 업데이트하며, 업데이트된 전역 상태를 확인한 UI 스레드에서는 알람을 실행시킵니다.

> **UI 스레드란?** <br /> 안드로이드 애플리케이션에서 사용자 인터페이스를 담당하는 메인 스레드로, 모든 UI 관련 작업을 처리하는 스레드입니다.
> <br /> 안드로이드에는 UI 스레드/메인 스레드와 Background 스레드가 존재합니다.
> <br /> <br /> **Background 스레드란?** <br /> UI 스레드와 별개로 동작하는 스레드로, 네트워크에서 데이터를 가져오는 등의 작업을 실행합니다.

### 문제 발생: ANR Error 발생 원인과 코드 개선하기

`react-native-background-actions` 라이브러리는 시간 제한없이 백그라운드 작업을 설정할 수 있기 때문에 계속해서 현재 시간을 확인하고, 등록된 알람 시간과 비교했습니다. 그러나 이러한 작업 때문에 큰 에러가 발생했습니다.

**원인: Foreground Service로 인한 ANR 에러**

앱이 켜진 상태가 5분 이상 지속된다면, 앱이 응답하지 않는다는 경고창과 함께 UI 상호작용(버튼 클릭 등)이 막히게 됐습니다. 그리고 이러한 에러는 ANR 에러라고 하며, 이는 Foreground Service 작업이 제한 시간 내에 종료되지 않았기 때문에 발생한 것이었습니다.

<img width="350" height="205px" alt="오류 화면" src="https://github.com/user-attachments/assets/1cd6723a-9306-4f8d-ac60-47b7f18c31f0" />

ANR 에러는 일정 시간 이상 UI 스레드가 차단될 경우 발생하는 오류로, 일반적으로 5초 이상 UI 스레드가 응답하지 않으면 발생합니다.

Foreground Service로 실행되는 로직은 Background 스레드에서 작업을 수행합니다. 이렇기 때문에 `react-native-background-actions` 라이브러리로 작성된 코드 또한 Background 스레드에서 동작하게 됩니다.

현재 백그라운드에서 사용자가 현재 시각을 지속적으로 확인하고 있습니다. 이런 작업이 종료되지 않고 지속적으로 실행되어 UI 스레드의 영역까지 차지하게 되어 UI 스레드의 동작을 차단하게 됐습니다. 이런 원인을 위해 ANR 에러가 발생했습니다.

**ANR 에러를 해결할 방법이 있을까?**

하지만 Foregorund Service를 활용하는 경우, 이 접근 방식 외에는 방법이 없다고 생각했습니다. 시간을 지속적으로 확인해야만 알람을 정확한 시간에 울릴 수 있기 때문입니다. 이 문제 이외에도 안드로이드의 Doze(절전) 모드에 진입하는 경우 OS가 앱의 백그라운드 작업을 종료시키게 됩니다.

> **[Doze 모드](https://developer.android.com/training/monitoring-device-state/doze-standby?hl=ko)란?** <br /> 기기가 전원에 연결되어 있지 않을 때 앱이 작동하는 방식을 관리하여 사용자의 배터리 수명을 연장하는 절전 기능 중 하나입니다. 잠자기 모드라고도 하며, 기기를 오랫동안 사용하지 않는 경우 앱의 백그라운드 CPU 및 네트워크 활동을 지연시켜 배터리 소모를 줄입니다.

이러한 문제를 해결하기 위해 다른 방식을 사용해야 한다는 생각을 했습니다.

### 해결 방법: Alarm Manager를 이용해 기기에 알람 예약하기(진행 중)

"OS 자체에 알람을 예약할 순 없을까?"라는 고민을 하게 되었습니다. 안드로이드에 존재하는 알람의 경우 **알람 또는 이벤트 리마인더 예약** 권한이 존재합니다. 이 권한에 대해 찾아 보니 [`AlarmManager`](https://developer.android.com/develop/background-work/services/alarms/schedule?hl=ko)를 사용하면 애플리케이션이 사용되지 않을 때에도 시간 기반 작업을 실행할 수 있다고 합니다.

`AlarmManager`는 시스템 알람에 이벤트를 예약하는 방식입니다. 시스템 서비스에 접근할 수 있는 권한을 제공하며, 특정 시간에 애플리케이션을 실행하도록 예약할 수 있습니다.

이를 통해 백그라운드 스레드가 메인 스레드에 영향을 주지 않아 ANR 에러를 방지할 수 있습니다. Alarm Manager에서는 Doze 모드를 피할 수 있습니다. 또한 `setAlarmClock()` 및 `setExactAndAllowWhileIdle()` 메서드를 사용할 때 Doze 모드에서도 예외적으로 작업을 수행할 수 있도록 시스템에서 허용합니다.

이를 통해 현재 발생하고 있는 문제를 해결할 수 있을 것이라 생각했고, `AlarmManager` 방식을 사용하는 방향으로 프로젝트를 개선 중에 있습니다.

## 구현 기능 5. 앱 실행 시 자동 로그인 진행

사용자가 앱 실행 시 최초 로그인 외에 별도의 로그인 절차 없이 자동으로 인증되도록 설계했습니다. 이렇게 하면 앱을 재실행할 때마다 반복적인 인증 과정을 거치지 않아 사용자 경험이 크게 향상될 것이라 생각했습니다.

### 1. 사용자 정보를 어디에 저장할까?

자동 로그인을 진행하기 위해서는 사용자의 정보를 앱에서 기억하고 있어야 합니다. 이때 사용자의 정보를 Database와 AsyncStorage 중 어디에 저장할 수 있을지 고민했습니다.

| 구분            | 장점                                                                                                                                                             | 단점                                                                                                                                                                       |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ❌ Database     | - 클라우드 기반으로 데이터 백업 가능 <br /> - 여러 기기에서 사용자 정보 동기화 가능                                                                              | - 자동 로그인처럼 빠른 로컬 접근에는 부적합 <br /> - 오프라인 접근 불가 <br /> - 보안 규칙 설정 필요                                                                       |
| ✅ AsyncStorage | - 로컬에 저장되어 오프라인에서도 접근 가능 <br /> - 빠른 읽기/쓰기 속도로 UX 향상 <br /> - 자동 로그인과 같은 기기 단독 기능에 최적화 <br /> - 사용 및 설정 간단 | - 여러 기기 간 데이터 동기화 불가 <br /> - 보안 처리(예: 암호화)는 직접 구현해야 함 <br /> - 저장 용량 제한 존재(수 MB 수준) <br /> - 데이터 손실 가능성 있음 (앱 삭제 시) |

자동 로그인을 진행하기 위해서는 GitHub 액세스 토큰이 저장되어야 합니다. 이 정보는 공유되거나 동기화될 필요가 없고, 오직 해당 기기에서만 참조되면 되기 때문에, 이러한 이유에서 AsyncStorage를 사용하는 것이 적합하다고 판단했습니다.

### 2. 자동 로그인 기능 구현하기

자동 로그인 기능은 아래와 같은 단계를 거치게 됩니다.

**단계 1: 최초 로그인 시 AsyncStorage에 사용자 토큰 저장**

사용자가 최초 로그인을 진행하게 되면 Github에서 토큰을 받아 AsyncStorage에 저장합니다.

이후 앱이 실행되면 가장 먼저 AsyncStorage에서 GitHub 액세스 토큰이 존재하는지 확인합니다. 이 토큰은 사용자가 이전에 로그인했던 기록으로, 별도의 입력 없이 인증 과정을 다시 수행할 수 있도록 도와줍니다. 토큰이 없다면 자동 로그인을 시도하지 않고, 이후 처리로 넘어갑니다.

**단계 2: AsyncStorage에서 토큰 확인**

앱이 실행되면 가장 먼저 로컬 저장소에서 GitHub 액세스 토큰이 존재하는지 확인합니다. 이 토큰은 사용자가 이전에 로그인했던 기록으로, 별도의 입력 없이 인증 과정을 다시 수행할 수 있도록 도와줍니다. 토큰이 없다면 자동 로그인을 시도하지 않고, 이후 처리로 넘어갑니다.

토큰이 존재할 경우, 해당 토큰을 이용해 Firebase 인증을 진행합니다. 인증이 성공하면 사용자의 로그인 상태를 감지하고, GitHub API를 통해 로그인 ID 같은 사용자 정보를 받아옵니다.

**단계 3: 로그인된 정보를 통해 데이터 가져오기**

로그인된 정보로 Firebase에서 사용자의 알람 관련 데이터를 가져와 설정하고, 자동 로그인 상태를 갱신한 뒤 앱의 메인 화면으로 이동합니다.

이러한 흐름을 통해 사용자는 앱을 열자마자 별도 로그인 과정 없이 자연스럽게 인증이 완료되고, 필요한 정보까지 자동으로 로드되는 경험을 하게 됩니다.

## 개인 회고

개인 프로젝트를 진행하면서 혼자 모든 것을 해내야 한다는 것이 버겁게 느껴지는 경우가 있었습니다. 의사 결정이나 실행하는 것에 있어서 의견 공유가 필요없으니 진행이 빠른 반면에 제 생각에만 갇혀 이상한 길로 빠지는 경우도 있었습니다. 또한 처음 접해 보는 것들을 혼자 시도해 보려고 하니 시간에 쫓겨 제대로 해내지 못 한 부분들도 있는 것 같습니다.

하지만 기능의 우선순위를 계속 고민하고 프로젝트의 정체성에 대해 생각하며 더 나은 방향으로 진행하기 위해 했던 노력들로 점차 제길을 찾아간다는 느낌을 받기도 했습니다.

아직 부족한 부분이 많으니 좀 더 업데이트를 진행하여 프로젝트를 발전시킬 생각입니다.
